#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May 17 11:19:35 2021

@author: marijn
"""
# Load settings image (.mat file). contains all relevant settings
import scipy.io
settings = scipy.io.loadmat('12 5 10x10 averaged grey.mat')

# Load image file using matploblib image library
from matplotlib import image
image = image.imread('12 5 10x10 averaged grey.png')

# Convert image to numpy array
import numpy as np
from numpy import asarray
npdata = asarray(image)

# Convert image to gray scale. Save to a new image 'GrayScale.png'. 
# Store gray scale image in new numpy array
from PIL import Image
im_grey = Image.open('12 5 10x10 averaged grey.png').convert('L')
im_grey.save('GrayScale.png')
im_grey_numpy = np.array(im_grey)

# Pick a random spot. The image conatins 10x10 spots but I need only one 
x_spot = 453
y_spot = 349

# Pick a range around the spot to analyze. The rest will be omitted.
xrange = 13
yrange = 13

x_low = x_spot - xrange
x_high = x_spot + xrange

y_low = y_spot - yrange
y_high = y_spot + yrange

# Crop image using the domain chosen in the previous step
# First selecting the right rows (y direction), then columns (x direction)
spot = im_grey_numpy[y_low : y_high , x_low : x_high]

# Save cropped array as a new image in PNG format (not necessary)
spotCropped = Image.fromarray(spot)
spotCropped.save('spotCropped.png')

"""
Plotting
"""

# 3 subplots
import matplotlib.pyplot as plt
fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(13,4),constrained_layout=True)

# First subplot: the image as a numpy 2D array. The array is called 'spot'
axes[0].imshow(spot)
axes[0].set_xlabel('pixels x')
axes[0].set_ylabel('pixels y')
axes[0].set_title('One of the spots')

# Second and Third plots: histograms in X and Y directions
# Make histograms, sum over rows and columns respectively, using all pixels
rowSum = spot.sum(axis = 0) 
columnSum = spot.sum(axis = 1) 

# Pixel 1D matrices (discreet)
xpixels = np.arange(x_low , x_high, 1)
ypixels = np.arange(y_low, y_high, 1)

"""
We want to fit our pixels with a Gaussian
"""

from scipy import optimize

# Define gaussian, having indepdent variable x and 3 parameters: amplitude, 
# mean and standard deviation
def gaussian(x, amplitude, mean, stddev):
    return amplitude * np.exp(-((x - mean) / 4 / stddev)**2)

# Initial values. The fitting algorithm needs an initial guess. Esimated from 
# plot of the spot. Respectively: amplitude, center, sigma
initialValuesX = 1000, 450, 2 
initialValuesY = 1000, 350, 2

# Fit data, starting with initial guess 'p0' to converge easier
# Store result in 'bestValuesX/Y' matrix
bestValuesX, covarX = optimize.curve_fit(gaussian, xpixels, rowSum, p0 = initialValuesX)
amplitudeX , meanX, stddevX = bestValuesX[0], bestValuesX[1], bestValuesX[2]

bestValuesY, covarY = optimize.curve_fit(gaussian, ypixels, columnSum, p0 = initialValuesY)
amplitudeY , meanY, stddevY = bestValuesY[0], bestValuesY[1], bestValuesY[2]

# Plotting the horizontal histogram and its fit
axes[1].grid()
axes[1].scatter(xpixels, rowSum)
axes[1].plot(xpixels, gaussian(xpixels,amplitudeX, meanX, stddevX),color='r')
axes[1].set_xlabel('horizontal pixels')
axes[1].set_ylabel('Counts')
axes[1].set_title('Histogram horizontal')

# Plotting the vertical histogram and its fit
axes[2].grid()
axes[2].scatter(ypixels, columnSum)
axes[2].plot(ypixels, gaussian(ypixels,amplitudeY, meanY, stddevY),color='r')
axes[2].set_xlabel('vertical pixels')
axes[2].set_ylabel('Counts')
axes[2].set_title('Histogram vertical')

# Saving and showing
plt.savefig('analyzingSpot.png', dpi = 400)
plt.show()

# Calculating standarddeviations in x and y directions, using pixel size
dx, dy = 4.65 , 4.65
sigmaX , sigmaY = stddevX * dx , stddevY * dy
print(sigmaX, sigmaY)
