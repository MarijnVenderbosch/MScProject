#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May 17 11:19:35 2021

@author: marijn
"""
# Libraries
import scipy.io
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from scipy import optimize


# Load settings image (.mat file). contains all relevant settings
matFile = scipy.io.loadmat('12 5 10x10 averaged grey.mat')

# The directory entry 'cam_frame' contains the camera image. Save as np array
cam_frame = matFile["cam_frame"]

# Covert to image using PIL and save
im = Image.fromarray(cam_frame)
file = im.save('12 5 10x10 averaged grey full camera.png')

# Pick a random spot. The image conatins 10x10 spots but I need only one 
x_spot = 329
y_spot = 460

# Pick a range around the spot to analyze. The rest will be omitted.
xrange = 5
yrange = 5

x_low = x_spot - xrange
x_high = x_spot + xrange

y_low = y_spot - yrange
y_high = y_spot + yrange

# Crop image using the domain chosen in the previous step
# First selecting the right rows (y direction), then columns (x direction)
spot = cam_frame[y_low : y_high , x_low : x_high]

# Save cropped array as a new image in PNG format (not necessary)l, commented
#spotCropped = Image.fromarray(spot)
#spotCropped.save('spotCropped.png')

"""
Plotting
"""

# 3 subplots
fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(13,4),constrained_layout=True)

# First subplot: the image as a numpy 2D array. The array is called 'spot'
axes[0].imshow(spot)
axes[0].set_xlabel('pixels x')
axes[0].set_ylabel('pixels y')
axes[0].set_title('One of the spots')

# Second and Third plots: histograms in X and Y directions
# Make histograms, sum over rows and columns respectively, using all pixels
rowSum = spot.sum(axis = 0) 
columnSum = spot.sum(axis = 1) 

# Pixel 1D matrices (discreet)
xpixels = np.arange(x_low , x_high, 1)
ypixels = np.arange(y_low, y_high, 1)

"""
We want to fit our pixels with a Gaussian
"""

# Define gaussian, having indepdent variable x and 3 parameters: amplitude, 
# mean and standard deviation
def gaussian(x, amplitude, mean, stddev):
    return amplitude * np.exp(-((x - mean) / 4 / stddev)**2)

# Initial values. The fitting algorithm needs an initial guess. Esimated from 
# plot of the spot. Respectively: amplitude, center, sigma
initialValuesX = 800, 329, 2 
initialValuesY = 800, 459, 2

# Fit data, starting with initial guess 'p0' to converge easier
# Store result in 'bestValuesX/Y' matrix
bestValuesX, covarX = optimize.curve_fit(gaussian, xpixels, rowSum, p0 = initialValuesX)
amplitudeX , meanX, stddevX = bestValuesX[0], bestValuesX[1], bestValuesX[2]

bestValuesY, covarY = optimize.curve_fit(gaussian, ypixels, columnSum, p0 = initialValuesY)
amplitudeY , meanY, stddevY = bestValuesY[0], bestValuesY[1], bestValuesY[2]

# Array for plotting fit (more accurate)
stepsForFit = 100
smallPixelsX = np.linspace(x_low , x_high , stepsForFit)
smallPixelsY = np.linspace(y_low , y_high , stepsForFit)

# Plotting the horizontal histogram and its fit
axes[1].grid()
axes[1].scatter(xpixels, rowSum)
axes[1].plot(smallPixelsX, gaussian(smallPixelsX,amplitudeX, meanX, stddevX),color='r')
axes[1].set_xlabel('horizontal pixels')
axes[1].set_ylabel('Counts')
axes[1].set_title('Histogram horizontal')

# Plotting the vertical histogram and its fit
axes[2].grid()
axes[2].scatter(ypixels, columnSum)
axes[2].plot(smallPixelsY, gaussian(smallPixelsY,amplitudeY, meanY, stddevY),color='r')
axes[2].set_xlabel('vertical pixels')
axes[2].set_ylabel('Counts')
axes[2].set_title('Histogram vertical')

# Saving and showing
plt.savefig('analyzingSpot.png', dpi = 400)
plt.show()

# Calculating standarddeviations in x and y directions, using pixel size
pixelSizeX, pixelSizeY = 4.65 , 4.65

# Converting from standard deviation to 1/e^2 radius 
beamWidthX = pixelSizeX * 2 * abs(stddevX)
beamWidthY = pixelSizeY * 2 * abs(stddevY)

print("beam withs x and y: ", beamWidthX, beamWidthY)
