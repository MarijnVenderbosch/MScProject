#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May 17 11:19:35 2021
@author: marijn
"""

# Libraries
import numpy as np
import matplotlib.pyplot as plt
import scipy.io # load .mat
from PIL import Image # save .np as .png
from scipy import optimize # fit data

# Load settings image (.mat file). contains all relevant settings
mat_file = scipy.io.loadmat('12 5 10x10 averaged grey.mat')

# The directory entry 'cam_frame' contains the camera image. Save as np array
cam_frame = mat_file["cam_frame"]

# Covert to image using PIL and save
full_view_camera = Image.fromarray(cam_frame)
png_file = full_view_camera.save('12 5 10x10 averaged grey full camera.png')

# Pick a random spot. The image conatins 10x10 spots but I need only one 
center_spot_x = 329
center_spot_y = 460

# Pick a range around the spot to analyze. The rest will be omitted.
range_x = 5
range_y = 5

lower_limit_frames_x = center_spot_x - range_x
higher_limit_frames_x = center_spot_x + range_x

lower_limit_frames_y = center_spot_y - range_y
higher_limit_frames_y = center_spot_y + range_y

# Crop image using the domain chosen in the previous step
# First selecting the right rows (y direction), then columns (x direction)
spot_cropped = cam_frame[lower_limit_frames_y : higher_limit_frames_y , lower_limit_frames_x : higher_limit_frames_x]

# Normalize
maximum_spot_intensity = np.max(spot_cropped)
spot_cropped_normalized = spot_cropped / maximum_spot_intensity

# Save cropped array as a new image in PNG format (not necessary)l, commented
#spot_cropped_png_file = Image.fromarray(spot_cropped)
#spot_cropped_png_file.save('spotCropped.png')

"""
Plotting
"""

# 3 subplots
fig, (ax1, ax2, ax3) = plt.subplots(ncols = 3, figsize = (9,3), constrained_layout = True)
# First subplot: the image as a numpy 2D array. The array is called 'spot'
matplotlib_imshow = ax1.imshow(spot_cropped_normalized, cmap = 'viridis')
ax1.set_xlabel('pixels x')
ax1.set_ylabel('pixels y')
ax1.set_title('One of the spots')
colorBar = plt.colorbar(matplotlib_imshow, location = 'left', ax = ax1, aspect = 30)
colorBar.set_label('Normalized Intensity')

# Second and Third plots: histograms in X and Y directions
# Make histograms, sum over rows and columns respectively, using all pixels
histogram_rows = spot_cropped.sum(axis = 0) 
histogram_columns = spot_cropped.sum(axis = 1) 

# Normalization; plot normalized intensity in both row and column histograms
maximum_histogram_rows = np.max(histogram_rows)
histogram_rows_normalized = histogram_rows / maximum_histogram_rows

maximum_histogram_columns = np.max(histogram_columns)
histogram_columns_normalized = histogram_columns / maximum_histogram_columns

# Pixel 1D matrices (discreet)
pixels_x = np.arange(lower_limit_frames_x, higher_limit_frames_x, 1)
pixels_y = np.arange(lower_limit_frames_y, higher_limit_frames_y, 1)

"""
We want to fit our pixels with a Gaussian
"""

# Define gaussian, having indepdent variable x and 3 parameters: amplitude, 
# mean and standard deviation
def gaussian(x, amplitude, mean, stddev):
    return amplitude * np.exp(-0.5 * ((x - mean) / stddev)**2)

# Initial values. The fitting algorithm needs an initial guess. Esimated from 
# plot of the spot. Respectively: amplitude, center, sigma
initial_values_x = 1, center_spot_x, 2 
initial_values_y = 1, center_spot_y, 2

# Fit data, starting with initial guess 'p0' to converge easier
# Store result in 'bestValuesX/Y' matrix
fit_parameters_x, covariance_x = optimize.curve_fit(gaussian, pixels_x, histogram_rows_normalized, p0 = initial_values_x)

amplitude_x = fit_parameters_x[0]
mean_x = fit_parameters_x[1]
stddev_x = fit_parameters_x[2]

fit_parameters_y, covariance_y = optimize.curve_fit(gaussian, pixels_y, histogram_columns_normalized, p0 = initial_values_y)

amplitude_y =fit_parameters_y[0]
mean_y = fit_parameters_y[1]
stddev_y = fit_parameters_y[2]

# Array for plotting fit (more accurate)
fitting_steps = 250
pixels_smaller_x = np.linspace(lower_limit_frames_x , higher_limit_frames_x , fitting_steps)
pixels_smaller_y = np.linspace(lower_limit_frames_y , higher_limit_frames_y , fitting_steps)

# Plotting the horizontal histogram and its fit
ax2.grid()
ax2.scatter(pixels_x, histogram_rows_normalized)
ax2.plot(pixels_smaller_x, gaussian(pixels_smaller_x, amplitude_x, mean_x, stddev_x), color='r')
ax2.set_xlabel('horizontal pixels')
ax2.set_ylabel('Normalized intensity')
ax2.set_title('Histogram horizontal')

# Plotting the vertical histogram and its fit
ax3.grid()
ax3.scatter(pixels_y, histogram_columns_normalized)
ax3.plot(pixels_smaller_y, gaussian(pixels_smaller_y, amplitude_y, mean_y, stddev_y), color='r')
ax3.set_xlabel('vertical pixels')
ax3.set_ylabel('Normlalized intensity')
ax3.set_title('Histogram vertical')

# Saving and showing
plt.savefig('analyzingSpot.png', dpi = 400)
plt.show()

# Calculating standarddeviations in x and y directions, using pixel size
pixel_size_x = 4.65
pixel_size_y = 4.65

# Converting from standard deviation to 1/e^2 radius 
beamwidth_x = pixel_size_x * 2 * abs(stddev_x)
beamwidth_y = pixel_size_y * 2 * abs(stddev_y)

print("beam withs x and y: ", beamwidth_x, 'and',  beamwidth_y)
